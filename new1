package com.tingyun.visboard.common.apioperation;

import cn.hutool.core.collection.CollectionUtil;
import cn.hutool.json.JSONUtil;
import com.google.common.base.Joiner;
import com.google.common.base.MoreObjects;
import com.google.common.collect.Lists;
import com.google.common.util.concurrent.RateLimiter;
import com.tingyun.visboard.common.apioperation.enums.*;
import com.tingyun.visboard.common.apioperation.enums.DataBaseEnum;
import com.tingyun.visboard.common.apioperation.enums.PipelineExecStrategyEnum;
import com.tingyun.visboard.common.apioperation.enums.PipelineParamSourceTypeEnum;
import com.tingyun.visboard.common.apioperation.enums.RequestDataTypeEnum;
import com.tingyun.visboard.common.apioperation.freemarkertag.DataPipelineFreeMarkerUtil;
import com.tingyun.visboard.common.datapipeline.UrlUtil;
import com.tingyun.visboard.common.datapipeline.PipilineNameEnun;
import com.tingyun.visboard.common.exception.BusinessException;
import com.tingyun.visboard.common.thread.CallableWithParams;
import com.tingyun.visboard.common.thread.ExecuterServiceUtil;
import com.tingyun.visboard.common.util.*;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.crypto.Data;
import java.nio.channels.Pipe;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.function.Supplier;

/***
 * 数据流水线控制器
 */
public class DataPipeLineController {


    public static String self_ref_key = "datapipiline_controller_self_ref_key";
    static boolean showJsonMapLog = false;

    /***
     * 控制在datapipelinecontroller 执行完毕之后，数据库是否进行关闭操作，默认关闭，此时进行查询时会返回数据库已关闭的提示
     */
    private boolean useSqlQuery = false;

    final static RateLimiter limiter = RateLimiter.create(UrlUtil.getDataPipelineControllerRateLimit());

    /***
     * 是否是在第一步的分步调试内,如果是在第一步的调试范围内，就只会执行到mapping映射这一步
     */
//    boolean isInFirstDebugMode = false;

    /***
     * 是否是在第二部的分步调试内
     */
    boolean isInSecondDebugMode = false;

    private static boolean strictMode = false;
    /***
     * dataPipeline执行完需要清除的表
     */
    private static List<String> clearTableList = new ArrayList<>();

    private static final Logger LOGGER = LoggerFactory.getLogger(DataPipeLineController.class);
    /***
     * dataPipeline分组集合
     */
    private List<DataPipelineGroup> dataPipelineGroups = new ArrayList<>();

    /***
     * datapipeline name 到对应的请求参数映射
     */
    private Map<String, Map<String, Object>> dataPipelineNameToRequestParams = new HashMap<>();

    /***
     * 用户当前请求上下文
     */
    private Map<String, Object> userRequestMap = new HashMap<>();

    /***
     * dataPipeline从id到对象的映射，方便快速取值
     */
    private Map<String, List<DataPipeline>> dataPipelineMap = new HashMap<>();

    /***
     * 返回数据格式化对象
     */
    private ResponseDataFormat responseDataFormat;

    /***
     * 公共sql connection
     */
    private Connection connection;

    /***
     * 所使用的数据库类型
     */
    private DataBaseEnum dataBaseEnum;

    /***
     *  配置调试模式下数据库的模式
     */
    public static DataBaseEnum debugModeDataBaseEnum;

    /***
     * 全局上下文数据库连接对象
     */
    private SqlOperation sqlOperation;

    /***
     * 全局上下文数据库连接对象
     */
    static SqlOperation sqlOperationForFile;
    /****
     * 用于授权的全局请求头，和全局请求cookie
     */
    private GlobalRequestContext globalRequestContext = new GlobalRequestContext();

    /***
     * 定义错误信息
     */
    String errorMsg;

    String executeLog;

    final String log_key = "log";

    /***
     * datapipelineController 级别的数据成处理sql
     */
    private String followSql;

    /***
     * 数据流水线版本，默认构造器使用的版本是 v1，兼容旧版
     */
    private Dversion dversion;

    void setInInterfaceDebugMode() {
        ExecuterServiceUtil.put("debug", true);
    }

    @Deprecated
    public DataPipeLineController addGroup(DataPipelineGroup dataPipelineGroup) {
        dataPipelineGroups.add(dataPipelineGroup);
        return this;
    }

    public DataPipeLineController addGroup() {
        dataPipelineGroups.add(new DataPipelineGroup());
        return this;
    }

    /***
     * 默认使用自定义版本
     * @param dversion
     */
    public DataPipeLineController(Dversion dversion){
        this.dversion = dversion;
        contrustorInit();
    }

    /***
     * 默认使用v1版本
     */
    public DataPipeLineController() {
        contrustorInit();
    }

    private void contrustorInit() {
        ExecuterServiceUtil.put(log_key, new StringBuffer());
        if (ApplicationContextProvider.getApplicationContext() != null) {
            this.sqlOperation = new SqlOperation(this);
        } else if (debugModeDataBaseEnum != null && debugModeDataBaseEnum.equals(DataBaseEnum.sqlLiteInFile)) {
            initSqlFileDataBase(DataBaseEnum.sqlLiteInFile);
        } else {
            this.sqlOperation = new SqlOperation(this);
        }
        ExecuterServiceUtil.put(self_ref_key,this);
    }

    DataPipeLineController(DataBaseEnum dataBaseEnum) {
        initSqlFileDataBase(dataBaseEnum);

    }

    private void initSqlFileDataBase(DataBaseEnum dataBaseEnum) {
        ExecuterServiceUtil.put(log_key, new StringBuffer());
        synchronized (DataPipeLineController.class) {
            this.dataBaseEnum = dataBaseEnum;
            if (DataPipeLineController.sqlOperationForFile != null) {
                this.sqlOperation = sqlOperationForFile;
            } else {
                this.sqlOperation = new SqlOperation(this);
                DataPipeLineController.sqlOperationForFile = sqlOperation;
            }
            this.sqlOperation.setDataPipeLineController(this);
        }
    }


    /***
     * 添加控制器载体
     * @param pipelineControllerPayload
     * @return
     */
    public DataPipeLineController addPipelineControllerPayload(PipelineControllerPayload pipelineControllerPayload) {

        AssertUtil.trueForError(CollectionUtil.isEmpty(dataPipelineGroups), String.format("未设置数据流水线分组payload=[%s]", pipelineControllerPayload));
        this.dataPipelineGroups.get(dataPipelineGroups.size() - 1).getPayloads().add(pipelineControllerPayload);

        pipelineControllerPayload.setDataPipelineGroup(this.dataPipelineGroups.get(dataPipelineGroups.size() - 1));

        return this;
    }

    public DataPipeLineController execute() {
        long startTime = System.currentTimeMillis();
        DataPipeLineController.limiter.acquire();
        DataPipeLineController result = execute2();
        long estimatedTime = System.currentTimeMillis() - startTime;
        PrintUtil.printInfo(LOGGER, String.format("总执行耗时%s秒", estimatedTime));
        return result;
    }

    /***
     * 在上层api没有处理businessExcepion时，自己捕捉异常
     * @return
     */
    public DataPipeLineController executeCatchException() {
        DataPipeLineController.limiter.acquire();
        try {
            execute2();
        } catch (Exception e) {
            PrintUtil.printInfo(LOGGER, ExceptionToStringUtil.exceptionToString(e));
            this.getResponseDataFormat().setResponseData(e.getMessage());
        }
        return this;
    }


    /***
     * 真正执行流水线
     * @return
     */
    public DataPipeLineController execute2() {

        try {
            for (
                    int i = 0; i < dataPipelineGroups.size(); i++) {
                DataPipelineGroup dataPipelineGroup = dataPipelineGroups.get(i);
                if (CollectionUtil.isNotEmpty(dataPipelineGroup.getPayloads())) {
                    Collections.sort(dataPipelineGroup.getPayloads(), new Comparator<PipelineControllerPayload>() {
                        @Override
                        public int compare(PipelineControllerPayload o1, PipelineControllerPayload o2) {
                            return (o1.getOrder() - o2.getOrder());
                        }
                    });
                    for (int j = 0; j < dataPipelineGroup.getPayloads().size(); j++) {
                        PipelineControllerPayload payload = dataPipelineGroup.getPayloads().get(j);
                        DataPipeline dataPipeline = payload.getDataPipeline(this);
                        AssertUtil.trueForError(dataPipeline == null, "get_business_list dataPipeline Object is null,controller=" + JSONUtil.toJsonStr(this));
                        AssertUtil.trueForError(payload.getPipelineExecStrategyEnum() == null, "PipelineExecStrategyEnum not set controller =" + JSONUtil.toJsonStr(this));
                        AssertUtil.trueForError(StringUtils.isBlank(dataPipeline.getPipelineName()), "pipeline name is empty,data=" + JSONUtil.toJsonStr(dataPipeline));
//                        AssertUtil.trueForError(dataPipelineMap.containsKey(dataPipeline.getPipelineName()),String.format("dataPipelineMap name=[%s] alreay exits,controller=[%s]",dataPipeline.getPipelineName(),JSONUtil.toJsonStr(this)));


                        dataPipelineNameToRequestParams.put(dataPipeline.getPipelineName(), dataPipeline.getFillRequestParams());
                        PrintUtil.printInfo(LOGGER, String.format("当前执行的控制器是[%s] dataPipeline是[%s]", payload.getPipelineExecStrategyEnum().getDesc(), dataPipeline.getPipelineName()));
                        if (payload.getPipelineExecStrategyEnum().equals(PipelineExecStrategyEnum.main)) {
                            if (CollectionUtil.isNotEmpty((dataPipelineMap.get(dataPipeline.getPipelineName())))) {
                                dataPipelineMap.get(dataPipeline.getPipelineName()).add(dataPipeline);
                            } else {
                                dataPipelineMap.put(dataPipeline.getPipelineName(), Lists.newArrayList(dataPipeline));
                            }

                            /**
                             * 主流水线开始执行
                             */
                            //初始化请求参数里的freemarker标签数据
                            dataPipeline.initFreeMarkerParamValue();
                            //初始化request header里的标签数据
                            dataPipeline.initRequestHeaderParams();
                            dataPipeline.pipelineControllerPayload = payload;
                            this.batchExecute(dataPipeline);
                        } else if (payload.getPipelineExecStrategyEnum().equals(PipelineExecStrategyEnum.foreach)) {
                            /**
                             * 父子请求/分发请求，父请求执行完，子请求执行多次
                             * 如果是分发请求的情况下,上面获取到的datapipeline每一次的数组循环都要是新的对象
                             */
                            //先获取请求内参数数组

                            List<Map<String, Object>> allPipelineParams = this.putTotalPipelineRequestParamsToArray(payload);
                            AssertUtil.trueForError(CollectionUtil.isEmpty(allPipelineParams),
                                    String.format("get_business_list all pipeline request params is empty controller=%s", JSONUtil.toJsonStr(this)));

                            dataPipeline.dropTableBeforeForeachLoop();
                            List<Future> futures = new ArrayList<>();
                            for (int z = 0; z < allPipelineParams.size(); z++) {
                                DataPipeline childLoopDataPipeline = payload.getDataPipeline(this);
                                //初始化请求参数里的freemarker标签数据
                                childLoopDataPipeline.initFreeMarkerParamValue();
                                //初始化request header里的标签数据
                                childLoopDataPipeline.initRequestHeaderParams();
                                Map<String, Object> paramsMap = allPipelineParams.get(z);
                                childLoopDataPipeline.pipelineControllerPayload = payload;
                                List<DataPipeline> childDataPipelines = dataPipelineMap.get(childLoopDataPipeline.getPipelineName());
                                if (CollectionUtil.isEmpty(childDataPipelines)) {
                                    childDataPipelines = Lists.newArrayList(childLoopDataPipeline);
                                } else {
                                    childDataPipelines.add(childLoopDataPipeline);
                                }
                                for (String key : paramsMap.keySet()) {
                                    if (paramsMap.get(key) != null) {
                                        try {
                                            childLoopDataPipeline.setRequestParam(key, paramsMap.get(key));
                                        } catch (Exception e) {
                                            PrintUtil.printInfo(LOGGER, "类型转换错误" + JSONUtil.toJsonStr(this) + ExceptionToStringUtil.exceptionToString(e));
                                            throw e;
                                        }
                                    } else {
                                        //入参为空时的处理逻辑
                                        childLoopDataPipeline.setRequestParam(key, "");
                                    }

                                }
                                if (z == 0) {
                                    childLoopDataPipeline.setIfFirstForeachLoop(true);
                                    this.batchExecute(childLoopDataPipeline);
                                    continue;
                                } else {
                                    childLoopDataPipeline.setIfFirstForeachLoop(false);
                                }
                                /***
                                 * 这个地方的入参存储，对于foreach循环情况先只做一次存储，会存在参数覆盖情况
                                 */
                                dataPipelineNameToRequestParams.put(childLoopDataPipeline.getPipelineName(), childLoopDataPipeline.getFillRequestParams());
                                futures.add(ExecuterServiceUtil.submit(new CallableWithParams<DataPipeLineController, DataPipeline, Object, Object>(new ImmutableTriple<>(this, childLoopDataPipeline, new Object())) {
                                    @Override
                                    public Object exec() {
                                        DataPipeLineController dataPipeLineController = this.getTriplet().getLeft();
                                        DataPipeline dataPipelineForExe = this.getTriplet().getMiddle();
                                        dataPipeLineController.batchExecute(dataPipelineForExe);
                                        return new Object();
                                    }
                                }));
//                            this.batchExecute(childLoopDataPipeline);
                            }
                            for (Future future : futures) {
                                try {
                                    future.get();
                                } catch (InterruptedException e) {
                                    PrintUtil.printInfo(LOGGER, ExceptionToStringUtil.exceptionToString(e));
                                    Thread.currentThread().interrupt();
                                } catch (ExecutionException e) {
                                    PrintUtil.printInfo(LOGGER, ExceptionToStringUtil.exceptionToString(e));
                                }
                            }
                        } else if (payload.getPipelineExecStrategyEnum().equals(PipelineExecStrategyEnum.one_by_one)) {
                            /***
                             * 串行请求，仅执行一次
                             */
                            /***
                             *  如果当前请求的执行策略是多个table的映射模式，在第二次执行时，就不再进行参数的初始化工作，不再需要，因为已经把第一次请求结果里的参数带入的datapipeline中，所以不再更新请求
                             */
                            if (ExecuteStrategyTypeEnum.multiple_table_mapping_process.equales(payload.getDataPipeline(this).getExecuteStrategyTypeEnum())) {
                                this.batchExecute(dataPipeline);
                                continue;
                            }
                            Map<String, Object> paramsMap = this.getMapRequestParam(payload);
                            if (CollectionUtil.isNotEmpty((dataPipelineMap.get(dataPipeline.getPipelineName())))) {
                                dataPipelineMap.get(dataPipeline.getPipelineName()).add(dataPipeline);
                            } else {
                                dataPipelineMap.put(dataPipeline.getPipelineName(), Lists.newArrayList(dataPipeline));
                            }

                            //填充参数
                            for (String key : paramsMap.keySet()) {
                                if (paramsMap.get(key) != null) {
                                    try {
                                        dataPipeline.setRequestParam(key, paramsMap.get(key));
                                    } catch (Exception e) {
                                        PrintUtil.printInfo(LOGGER, "类型转换错误" + JSONUtil.toJsonStr(this) + (ExceptionToStringUtil.exceptionToString(e)));
                                        throw e;
                                    }
                                } else {
                                    //入参为空时的处理逻辑
                                    dataPipeline.setRequestParam(key, "");
                                }

                            }

                            dataPipelineNameToRequestParams.put(dataPipeline.getPipelineName(), dataPipeline.getFillRequestParams());
                            dataPipeline.pipelineControllerPayload = payload;
                            //初始化请求参数里的freemarker标签数据
                            dataPipeline.initFreeMarkerParamValue();
                            //初始化request header里的标签数据
                            dataPipeline.initRequestHeaderParams();
                            this.batchExecute(dataPipeline);
                        }

                    }
                }
            }
//            if(_DatapipelineHelper.getIsInFirstDebugMode(this)){
//
//            }

            if (StringUtils.isNotBlank(followSql)) {
                sqlOperation.processFollowSql(followSql);
            }
            formatData();

        } finally {

            deletePipelinePayloadGroupRef();
            dropTable();
            StringBuffer log = (StringBuffer) ExecuterServiceUtil.get("log");
            if (log == null) {
                log = new StringBuffer();
            }
            this.executeLog = log.toString();
            ExecuterServiceUtil.delete();
        }
        return this;
    }

    /**
     * 自动清楚datapipeline group组内的循环引用
     */
    private void deletePipelinePayloadGroupRef() {

        for (DataPipelineGroup dataPipelineGroup : dataPipelineGroups) {
            for (PipelineControllerPayload pipelineControllerPayload : dataPipelineGroup.getPayloads()) {
                pipelineControllerPayload.setDataPipelineGroup(null);
            }

        }
    }


    public void dropTable() {
        try {
            if (!(sqlOperation.sql instanceof SqlLiteInMemeory) && !useSqlQuery) {
                synchronized (DataPipeLineController.class) {
                    String sql = "SELECT tbl_name  as 'tableName' FROM sqlite_master WHERE type='table'";
                    List<Map<String, Object>> tableList = getSqlOperation().queryList(sql);

                    tableList.forEach(a -> {
                        Statement stmt = null;
                        try {
                            stmt = sqlOperation.getConnection().createStatement();
                        } catch (SQLException e) {
                            com.tingyun.visboard.common.util.PrintUtil.staticPrintException(e);
                        }
                        String tableName = (String) a.get("tableName");
                        if (tableName.startsWith("_xx_")) {
                            {
                                try {
                                    String exesql = "drop table " + tableName;
                                    stmt.executeUpdate(exesql);
                                    PrintUtil.printInfo(LOGGER, exesql);
                                } catch (Exception e) {
                                    PrintUtil.printInfo(LOGGER, ExceptionToStringUtil.exceptionToString(e));
                                }
                            }
                        }
                    });
                }
            } else {
                if (!useSqlQuery) {
                    try {
                        sqlOperation.getConnection().close();
                    } catch (SQLException e) {
                        com.tingyun.visboard.common.util.PrintUtil.staticPrintException(e);
                    }
                }
            }


        } catch (Exception e) {

            PrintUtil.printInfo(LOGGER, JSONUtil.toJsonStr(ExceptionToStringUtil.exceptionToString(e)));
            errorMsg = e.getMessage();
        }
        ExecuterServiceUtil.delete();
    }


    /***
     * 适用于子请求，进行多个分发处理的情况，需要拿到一个入参数组，并且在每个数组的map对象里拼接好所有的入参
     * 这个方法对于标签的类型，主要是将含有crosssql类型的标签转化为crosssqlRule的对象，然后整个foreach循环的基参数通过sql查询出结果，然后放入待遍历的集合中
     * 但是循环执行时（也就是这个方法的调用方），本身内部的datapipeline对象都是循环内从supplier中get到的新对象，所以内部的标签数据需要再一次执行一遍，initFreeMarkerParamValue和initRequestHeaderParams
     * @param pipelineControllerPayload
     * @return
     */
    public List<Map<String, Object>> putTotalPipelineRequestParamsToArray(PipelineControllerPayload pipelineControllerPayload) {

        List<Map<String, Object>> paramMapList = new ArrayList<>();
        DataPipeline dataPipeline = pipelineControllerPayload.getDataPipeline(this);

        //初始化请求参数里的freemarker标签数据
        dataPipeline.initFreeMarkerParamValue();
        //初始化request header里的标签数据
        dataPipeline.initRequestHeaderParams();
        List<CrossPipelineTransDataRule> crossPipelineTransDataRules = dataPipeline.getCrossPipelineTransDataRuleList();

        /**
         * 存放从requestParam中取到的参数，因为是返回数组列表，所以暂时公共存储，最终全都赋值到每个数组对象里
         */
        Map<String, Object> requestCommonParams = new HashMap<>();

        for (int i = 0; i < crossPipelineTransDataRules.size(); i++) {
            CrossPipelineTransDataRule crossPipelineTransDataRule = crossPipelineTransDataRules.get(i);
            //这个取值逻辑可能需要废掉？暂时不确定
            if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_pipeline_request_param)) {
                /***
                 * 从另一个pipeline中取到需要的请求参数,这里面获取到的参数一般是公共参数，放到了commonmap集合里面，最终在这个方法结束时，会将所有的common入参，进一步写入到每个子请求的上下文里
                 */
                Map<String, Object> targetRequestParams = this.dataPipelineNameToRequestParams.get(crossPipelineTransDataRule.getTargetPipelineId());
                AssertUtil.trueForError(CollectionUtil.isEmpty(targetRequestParams), "target pipeline request params is empty pipelineId=" + crossPipelineTransDataRule.getTargetPipelineId());
                requestCommonParams.put(crossPipelineTransDataRule.getCurrentSetFieldName(), targetRequestParams.get(crossPipelineTransDataRule.getRequestParamKey()));
            } else if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_sql_query)) {

                /***
                 * 这种情况仅适用于子任务接收的参数都是固定的几个 keyvalue 形式的参数
                 * 如果对于接收形式是数组的形式，需要另外单独处理，一般接口也没有这样玩的，那就太变态了
                 * 一般对于数组的参数接收形式，主要是分发执行完了之后的聚合接口，需要这样玩
                 */
                List<Map<String, Object>> queryMapList = this.getSqlOperation().queryList(crossPipelineTransDataRule.getSqlSelect());
                AssertUtil.trueForError(CollectionUtil.isEmpty(queryMapList), String.format("result is empty from select data=" + JSONUtil.toJsonStr(pipelineControllerPayload)));

                for (Map<String, Object> param : queryMapList) {

                    Object object = param.get(crossPipelineTransDataRule.getSqlFieldName());
                    if (object != null) {
                        Map<String, Object> paramMap = new HashMap<>();
                        paramMap.put(crossPipelineTransDataRule.getCurrentSetFieldName(), object);
                        paramMapList.add(paramMap);
                    } else {

                        String errorMsg = String.format("根据sqlField key 取值没有取到 key = [%s],param=[%s],target key=[%s]", crossPipelineTransDataRule.getSqlFieldName(), param, crossPipelineTransDataRule.getCurrentSetFieldName());
                        DataPipeLineController.error(errorMsg);
                        PrintUtil.printInfo(LOGGER, errorMsg);
                    }
                }
            }
        }

        if (CollectionUtil.isNotEmpty(requestCommonParams)) {
            for (Map<String, Object> map : paramMapList) {
                for (String key : requestCommonParams.keySet()) {
                    map.put(key, requestCommonParams.get(key).toString());
                }
            }
        }

        return paramMapList;

    }


    /***
     * 主要适用于执行一次请求的情况，获取执行参数<br>
     * 1:第一种是顺序执行
     * 2:第二种是聚合请求(某些参数就有可能为数组)
     * @param pipelineControllerPayload
     * @return
     */
    private Map<String, Object> getMapRequestParam(PipelineControllerPayload pipelineControllerPayload) {

        Map<String, Object> requestCommonParams = new HashMap<>();
        List<CrossPipelineTransDataRule> crossPipelineTransDataRuleList = pipelineControllerPayload.getDataPipeline(this).getCrossPipelineTransDataRuleList();
        for (CrossPipelineTransDataRule crossPipelineTransDataRule : crossPipelineTransDataRuleList) {

            /***
             * 判断是否需要使用list查询
             */
            boolean useListQuery = crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_sql_query)
                    && RequestDataTypeEnum.isArrayType(crossPipelineTransDataRule.getRequestDataTypeEnum());

            /***
             * 判断是否需要使用one查询
             */
            boolean useOneQuery = crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_sql_query)
                    && !RequestDataTypeEnum.isArrayType(crossPipelineTransDataRule.getRequestDataTypeEnum());

            if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_user_request_param)) {
                throw new BusinessException("未实现");
            } else if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_pipeline_request_param)) {
                /***
                 * 从另一个pipeline中取到需要的请求参数
                 */
                Map<String, Object> targetRequestParams = this.dataPipelineNameToRequestParams.get(crossPipelineTransDataRule.getTargetPipelineId());
                AssertUtil.trueForError(CollectionUtil.isEmpty(targetRequestParams), "target pipeline request params is empty pipelineId=" + crossPipelineTransDataRule.getTargetPipelineId());
                requestCommonParams.put(crossPipelineTransDataRule.getCurrentSetFieldName(), targetRequestParams.get(crossPipelineTransDataRule.getRequestParamKey()));
            } else if (useListQuery) {

                /***
                 * 这种情况仅适用于子任务接收的参数都是固定的几个 keyvalue 形式的参数
                 * 如果对于接收形式是数组的形式，需要另外单独处理，一般接口也没有这样玩的，那就太变态了
                 * 一般对于数组的参数接收形式，主要是分发执行完了之后的聚合接口，需要这样玩
                 */
                List<Map<String, Object>> resultMapList = this.getSqlOperation().queryList(crossPipelineTransDataRule.getSqlSelect());

                AssertUtil.trueForError(CollectionUtil.isEmpty(resultMapList), String.format("result is empty from select data=" + JSONUtil.toJsonStr(pipelineControllerPayload)));


               /* if(crossPipelineTransDataRule.getRequestDataTypeEnum().equals(RequestDataTypeEnum.foreach_array_object)){
                    //如果是object数组类型，就直接放入对象了
                    requestCommonParams.put(crossPipelineTransDataRule.getCurrentSetFieldName(),resultMapList);
                }else*/
                {
                    /***
                     * 上面接收的参数类型是数组，就要做select结果的合并操作
                     */
                    List<Object> paramList = new ArrayList<>();
                    for (int i = 0; i < resultMapList.size(); i++) {
                        Map<String, Object> selectResultObj = resultMapList.get(i);
                        if (selectResultObj.containsKey(crossPipelineTransDataRule.getSqlFieldName())) {
                            Object value = selectResultObj.get(crossPipelineTransDataRule.getSqlFieldName());
                            paramList.add(value);
                        } else {
                            /***
                             * 如果是空数组的,暂时不做处理
                             */
                            PrintUtil.printInfo(LOGGER, String.format("result %s is empty", i));
                        }
                    }
                    requestCommonParams.put(crossPipelineTransDataRule.getCurrentSetFieldName(), paramList);
                }


            } else if (useOneQuery) {
                Map<String, Object> resultMapList = getSqlOperation().queryOne(crossPipelineTransDataRule.getSqlSelect());
                //查询结果就直接返回了，入参类型不对？使用数据库内置函数自己进行转换吧。。。
                requestCommonParams.putAll(resultMapList);
            }

        }
        return requestCommonParams;
    }

    /**
     * 自批量执行
     *
     * @return
     */
    public DataPipeline batchExecute(DataPipeline dataPipeline) {

        long startTime = System.currentTimeMillis();
        try {
            if (ExecuteStrategyTypeEnum.singleRequest.equals(dataPipeline.getExecuteStrategyTypeEnum())) {
                singleExec(dataPipeline);


            } else if (ExecuteStrategyTypeEnum.first_debug_mode_for_h5.equals(dataPipeline.getExecuteStrategyTypeEnum())) {
                firstDebugModeExec(dataPipeline);


            } else if (ExecuteStrategyTypeEnum.multiple_table_mapping_process.equals(dataPipeline.getExecuteStrategyTypeEnum())) {
                multipleTableMappingDataPipelineExec(dataPipeline);


            } else if(ExecuteStrategyTypeEnum.auto_mapping.equales(dataPipeline.getExecuteStrategyTypeEnum())){
                this.automappingExec(dataPipeline);
            } else  {
                normalExec(dataPipeline);
            }

        } catch (Exception e) {
            PrintUtil.printInfo(LOGGER, JSONUtil.toJsonStr(ExceptionToStringUtil.exceptionToString(e)));
            this.errorMsg = e.getMessage();
        }

        /***
         * 如果extDataPipeline有值，就需要再单独执行一次table，由于第一个mapping规则就是datapipeline默认的，所以就跳过了
         */
        if (dataPipeline.extMappingRule.size() > 1) {
            PrintUtil.printInfo(LOGGER, "存在多个table");
            MappingRuleDto mappingRuleDto = dataPipeline.extMappingRule.pollLast();
            if (mappingRuleDto != null) {
                MappingRuleDto childTableMappingPipeline = mappingRuleDto;
                dataPipeline.mappingRuleDto = childTableMappingPipeline;

                /***
                 * 配置下一步的批量执行策略
                 */
                dataPipeline.setExecuteStrategyTypeEnum(ExecuteStrategyTypeEnum.multiple_table_mapping_process);
                dataPipeline.setPipelineName(childTableMappingPipeline.tableName);
//                dataPipeline.getCustomAddInsertColumnValueRules().clear();
                PrintUtil.printInfo(LOGGER, childTableMappingPipeline.tableName + "配置新的table映射规则");
                /***
                 * 同时更新字段对应的自定义表达式或者值映射
                 */
                MappingRuleDto.updateDatapipelineCustomExpressOrValue(dataPipeline, mappingRuleDto);
                this.addGroup(new DataPipelineGroup());
                this.addPipelineControllerPayload(new PipelineControllerPayload()
                        .setDataPipeline(new Supplier<DataPipeline>() {
                            @Override
                            public DataPipeline get() {
                                return dataPipeline;
                            }
                        }).setPipelineExecStrategyEnum(PipelineExecStrategyEnum.one_by_one));

            }
        }


        long estimatedTime = System.currentTimeMillis() - startTime;

        PrintUtil.printInfo(LOGGER, String.format("datapipeline[%s]执行耗时%s秒,线程=[%s]", dataPipeline.getPipelineName(), estimatedTime, Thread.currentThread().getName()));
        return dataPipeline;
    }

    public void normalExec(DataPipeline dataPipeline) throws SQLException {
        /***
         * 现行初始化表结构，保证后续的sql查询不为空
         */
        dataPipeline.initDataBase();

        dataPipeline.executeRequest();
        /***
         * 如果是单独的请求逻辑，就直接返回
         */
        dataPipeline.analysisData();

        dataPipeline.getColumnsDataFromJsonMap();

        //获取了插入的map字段以及值之后，开始判断是否需要填充自定义插入列的值
        if (CollectionUtil.isNotEmpty(dataPipeline.getCustomAddInsertColumnValueRules())) {
            customAndInsertColumnValueRules(dataPipeline);
        }

        dataPipeline.insertData();
    }

    /***
     * 多个table映射时的执行策略
     * @param dataPipeline
     * @throws SQLException
     */
    public void multipleTableMappingDataPipelineExec(DataPipeline dataPipeline) throws SQLException {
        /***
         * 现行初始化表结构，保证后续的sql查询不为空
         */
        dataPipeline.initDataBase();

        dataPipeline.getColumnsDataFromJsonMap();

        customAndInsertColumnValueRules(dataPipeline);

        dataPipeline.insertData();
    }

    public void singleExec(DataPipeline dataPipeline) {
        /***
         * 现行初始化表结构，保证后续的sql查询不为空
         */
//        if(!dataPipeline.isSingleRequest){
//            dataPipeline.initDataBase();
//        }

        dataPipeline.executeRequest();
        /***
         * 如果是单独的请求逻辑，就直接返回
         */
    }

    public void firstDebugModeExec(DataPipeline dataPipeline) {
        /***
         * 现行初始化表结构，保证后续的sql查询不为空
         */
        dataPipeline.initDataBase();

        dataPipeline.executeRequest();
        /***
         * 如果是单独的请求逻辑，就直接返回
         */
        dataPipeline.analysisData();

    }


    /***
     * 自动将请求结果进行映射到table的操作
     * @param dataPipeline
     */
    public void automappingExec(DataPipeline dataPipeline) throws SQLException {
        /***
         * 现行初始化表结构，保证后续的sql查询不为空
         */
//        dataPipeline.initDataBase();

        dataPipeline.executeRequest();
//        /***
//         * 如果是单独的请求逻辑，就直接返回
//         */
//        dataPipeline.analysisData();
//
//        dataPipeline.getColumnsDataFromJsonMap();
//
//        //获取了插入的map字段以及值之后，开始判断是否需要填充自定义插入列的值
//        if(CollectionUtil.isNotEmpty(dataPipeline.getCustomAddInsertColumnValueRules())){
//            customAndInsertColumnValueRules(dataPipeline);
//        }

//        dataPipeline.insertData();

        /***
         * 当下阶段只进行json automapping映射
         */
        String responseBody = dataPipeline.getResponseBody();
        this.autoMappingToTableForPipelineExe(dataPipeline.getPipelineName(),responseBody);

    }

    /***
     * 这里是旧的自定义值得方式方法，已经过时，但是系统中仍存在新的地方的引用，所以暂时保存
     * @param dataPipeline
     */
//    @Deprecated
    private void customAndInsertColumnValueRules(DataPipeline dataPipeline) {

        long startTime = System.currentTimeMillis();

        List<CrossPipelineTransDataRule> crossPipelineTransDataRules = dataPipeline.getCustomAddInsertColumnValueRules();
        for (CrossPipelineTransDataRule crossPipelineTransDataRule : crossPipelineTransDataRules) {
            if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_pipeline_request_param)) {
                /***
                 * 从另一个pipeline中取到需要的请求参数,如果是在foreach策略下，并且pipeline名字和当前名字一样，就直接使用当前pipeline取值，否则多线程下会有名字覆盖问题
                 */
                Object crossPipelineValue = null;
                boolean isNeedGetDataFromCurrentPipeline = dataPipeline.pipelineControllerPayload.getPipelineExecStrategyEnum().equals(PipelineExecStrategyEnum.foreach)
                        && crossPipelineTransDataRule.getTargetPipelineId().equals(dataPipeline.getPipelineName());
                if (isNeedGetDataFromCurrentPipeline) {
                    crossPipelineValue = dataPipeline.getFillRequestParams().get(crossPipelineTransDataRule.getRequestParamKey());
                } else {
                    Map<String, Object> targetRequestParams = this.dataPipelineNameToRequestParams.get(crossPipelineTransDataRule.getTargetPipelineId());
                    crossPipelineValue = targetRequestParams.get(crossPipelineTransDataRule.getRequestParamKey());
                    AssertUtil.trueForError(CollectionUtil.isEmpty(targetRequestParams), "target pipeline request params is empty pipelineId=" + crossPipelineTransDataRule.getTargetPipelineId());

                }

                List<Map<String, Object>> inserDataMapList = dataPipeline.getInsertDataMapList();
                for (Map<String, Object> insertObjMap : inserDataMapList) {
                    insertObjMap.put(crossPipelineTransDataRule.getCurrentSetFieldName(), crossPipelineValue);
                }
            } else if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_user_request_param)) {
                for (Map<String, Object> insertObjMap : dataPipeline.getInsertDataMapList()) {
                    insertObjMap.put(crossPipelineTransDataRule.getSqlFieldName(), this.userRequestMap.get(crossPipelineTransDataRule.getRequestParamKey()));
                }
            } else if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.user_custom)) {
                /***
                 * 使用自定义值类型时
                 */

//                Map<String,Object> requestMap = dataPipeline.getFillRequestParams();
//                Map<String,Object> currentDataPipelineRequestMap =
//                Object express = crossPipelineTransDataRule.getCustomValue();
                String value = DataPipelineFreeMarkerUtil.fillSelectSql(String.valueOf(crossPipelineTransDataRule.getCustomValue()), ListAndMapUtil.sytheticMaps(Lists.newArrayList(this.getTagUserRequestMap(), dataPipeline.getTagUserRequestMap(), this.getDataPipelineContext(), new HashMap<>())));
                crossPipelineTransDataRule.setCustomValue(value);
                List<Map<String, Object>> inserDataMapList = dataPipeline.getInsertDataMapList();
                for (Map<String, Object> insertObjMap : inserDataMapList) {
                    insertObjMap.put(crossPipelineTransDataRule.getCurrentSetFieldName(), value);
                }
            } else {
                throw new BusinessException("Set get_business_list parameter channel not supported,dataPipeline=" + JSONUtil.toJsonStr(dataPipeline));
            }
        }

        long estimatedTime = System.currentTimeMillis() - startTime;
        PrintUtil.printInfo(LOGGER, String.format("datapipeline[%s] customAndInsertColumnValueRules总执行耗时%s秒", dataPipeline.getPipelineName(), estimatedTime));

    }

    public DataPipeLineController formatData() {

        if (this.responseDataFormat != null) {
            if (this.responseDataFormat.getUseTag()) {
                this.responseDataFormat.tagAnalyse(this);
            } else {
                this.responseDataFormat.doQueryAndFillSqlEnvTemplate(this);
            }
            this.responseDataFormat.format();
        }
        return this;
    }

    public ResponseDataFormat getResponseDataFormat() {
        return responseDataFormat;
    }

    public DataPipeLineController setResponseDataFormat(ResponseDataFormat responseDataFormat) {
        this.responseDataFormat = responseDataFormat;
        this.responseDataFormat.dataPipeLineController = this;
        return this;
    }

    public boolean isStrictMode() {
        return strictMode;
    }

    public DataPipeLineController setStrictMode(boolean strictMode) {
        this.strictMode = strictMode;
        return this;
    }

    public static void error(String message) {
        if (strictMode) {
            throw new BusinessException(message);
        }
    }

    Object getValueByCrossPipelineTransDataRule(CrossPipelineTransDataRule crossPipelineTransDataRule) {
        if (crossPipelineTransDataRule != null) {

            if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_pipeline_request_param)) {
                /***
                 * 从另一个pipeline中取到需要的请求参数
                 */
                Map<String, Object> targetRequestParams = this.dataPipelineNameToRequestParams.get(crossPipelineTransDataRule.getTargetPipelineId());
                AssertUtil.trueForError(CollectionUtil.isEmpty(targetRequestParams), "target pipeline request params is empty pipelineId=" + crossPipelineTransDataRule.getTargetPipelineId());
                return targetRequestParams.get(crossPipelineTransDataRule.getRequestParamKey());
            } else if (crossPipelineTransDataRule.getPipelineGetParamTypeEnum().equals(PipelineParamSourceTypeEnum.by_user_request_param)) {
                return getValueByUserRequest(crossPipelineTransDataRule.getRequestParamKey());
            } else {
                throw new BusinessException("Set get_business_list parameter channel not supported,dataPipeline=");
            }
        }
        return null;
    }

    /***
     * 将请求体里的json参数作为全局作用域key放入 datapipelineController上下文作用域中
     * 可以在pipeline请求体或者在数据库中作为查询入参使用，入参取值方式 ${_request.jsonkey}
     * 取得数组中的某个值 ${_request.jsonkey[index].name}
     * @param object
     * @return
     */
    public DataPipeLineController addJsonRequestParam(Object object) {
        if (object != null) {
            this.userRequestMap.putAll(JacksonMapJsonUtil.objToMap(object));
        }
        return this;
    }

    /***
     * 添加用户请求上下文，添加完的请求入参，可以在后续的pipeline请求中或者在数据库查询中作为入参使用
     * @param key
     * @param value
     * @return
     */
    public DataPipeLineController addUserRequestParam(String key, Object value) {
        this.userRequestMap.put(key, value);
        return this;
    }

    Object getValueByUserRequest(String key) {
        return this.userRequestMap.get(key);
    }


    /***
     * 获取用户请求作用域对象集合
     * @return
     */
    Map<String, Object> getUserRequestMap() {
        return this.userRequestMap;
    }

    /***
     * 获取dataPipeline上下文作用
     * @return
     */
    Map<String, Map<String, Object>> getDataPipelineNameToRequestParams() {
        return this.dataPipelineNameToRequestParams;
    }

    public SqlOperation getSqlOperation() {
        return this.sqlOperation;
    }

    public DataBaseEnum getDataBaseEnum() {
        return dataBaseEnum;
    }

    public void setDataBaseEnum(DataBaseEnum dataBaseEnum2) {
        dataBaseEnum = dataBaseEnum2;
    }

    public GlobalRequestContext getGlobalRequestContext() {
        return globalRequestContext;
    }

    public DataPipeline getDataPipelineByName(String name) {
        if (CollectionUtil.isNotEmpty(this.dataPipelineMap.get(name))) {
            return this.dataPipelineMap.get(name).get(0);
        }
        return null;
    }

    public List<DataPipeline> getDataPipelineListByName(String name) {
        if (CollectionUtil.isNotEmpty(this.dataPipelineMap.get(name))) {
            return this.dataPipelineMap.get(name);
        }
        return null;
    }


    public Object toJacksonObject() {

        try {
            String reponseDataReplaceNull = null;
            AssertUtil.trueForError(this.getResponseDataFormat() == null, "数据格式化没有配置");
            AssertUtil.trueForError(StringUtils.isBlank(this.getResponseDataFormat().getReponseData()), "返回数据为空");
            if (StringUtils.isNotBlank(this.getResponseDataFormat().getReponseData())) {
                reponseDataReplaceNull = this.getResponseDataFormat().getReponseData()/*.replaceAll("null","0").replaceAll("NULL","0").replaceAll("Null","0")*/;
            } else {
                reponseDataReplaceNull = "{}";
            }
            return JacksonMapJsonUtil.parseString(reponseDataReplaceNull);
        } catch (Exception e) {

            LOGGER.info("reponse data format error:" + ExceptionToStringUtil.exceptionToString(e));
            //如果格式化失败就返回默认的字符串数据，起码能知道错误在哪
            return this.getResponseDataFormat().getReponseData();
        }

    }

    DataPipeLineController addClearTable(String tableName) {
        clearTableList.add(tableName);
        return this;
    }

    /***
     * 获取用户tag标签对应的作用域上下文,在使用标签时，<@CrossSql></@CrossSql> <@Auther></@Auther>
     * 用户请求作用域上下文,格式类似 _request.username = xiaoming
     * @return
     */
    Map<String, Object> getTagUserRequestMap() {
        Map<String, Object> userRequestContextMap = new HashMap<>();
        Map<String, Object> userRequestMap = this.getUserRequestMap();

        userRequestContextMap.put(Const.userRequestContextMapPrefix, userRequestMap);
        return userRequestContextMap;
    }

    /***
     * 获取dataPipeline请求上下文
     * dataPipeline 作用域上下文，格式类似 xxxx.username = liming
     * @return
     */
    Map<String, Object> getDataPipelineContext() {
        Map<String, Object> dataPipelineContextMap = new HashMap<>();
        Map<String, Object> pipelineParam = new HashMap<>();
        for (String key : this.getDataPipelineNameToRequestParams().keySet()) {
            dataPipelineContextMap.put(key, this.getDataPipelineNameToRequestParams().get(key));

        }

        return dataPipelineContextMap;
    }

    public void useSqlQuery() {
        this.useSqlQuery = true;
    }
    void setUseSqlQuery(boolean useSqlQuery) {
        this.useSqlQuery = useSqlQuery;
    }

    public static void showJsonMappingLog(boolean b) {
        DataPipeLineController.showJsonMapLog = b;
    }

    public DataPipeLineController setFollowSql(String followSql) {
        this.followSql = followSql;
        return this;
    }

    /***
     * 动态生成json table 配置，将其注入到datapipeline controller中，放置在datapipeline Controller 执行队列第一位里，添加到表头
     * @param json
     * @return
     */
    public DataPipeLineController jsonAutoMappingToTable(String json) {
        DataPipeline dataPipeline = new DataPipeline();
        StringBuilder outputNoBeginEndTag = new StringBuilder();
        StringBuilder outputwithBeginEndTag = new StringBuilder();
        JsonToListMapUtil jsonToListMapUtil = new JsonToListMapUtil(json, outputNoBeginEndTag, outputwithBeginEndTag, dataPipeline);

        List<KeyValue> list = jsonToListMapUtil.getJsonListMap();

        /***
         * 过滤出来合适keyvalue数据
         */
        List<KeyValue> filterList = jsonAutoMappingMessageFilter(list);

        Map<String, List<KeyValue>> listMap = AutoGenerateJsonTable.getGroupPath(filterList);
        Map<String, Set<KeyValue>> setMap = AutoGenerateJsonTable.compressionPath(listMap);

//        KeyValue keyValue = new KeyValue();
//        keyValue.setKey("_.data.xAxis.categories[].value");
//        keyValue.setValue("8888");
//        setMap.put("_.data.xAxis.categories[].value",keyValue);
        List<TableMappingRuleConfig> jsonToSqlColumnMaps = new ArrayList<>();
        for (String key : setMap.keySet()) {
            /***
             * 将datapipeline引入传入mapping rule的添加程序中，表的映射规则会自动添加到datapipeline中
             */
            TableMappingRuleConfig tableMappingRuleConfig = new TableMappingRuleConfig(dataPipeline);
            Set<KeyValue> keyValues = setMap.get(key);
            key = key.replace(".", "P");
            key = key.replace("_", "L");
            key = key.replace("[]", "A");
            key = key.replace("#", "W");
            tableMappingRuleConfig.setTableName(key);

            Map<String, String> repeatValidateMap = new HashMap<>();
            for (KeyValue keyValue : keyValues) {
                String path = keyValue.getKey();
                Object value = keyValue.getValue();
                String fieldName = path.replace(".", "P");
                fieldName = fieldName.replace("_", "L");
                fieldName = fieldName.replace("[]", "A");
                fieldName = fieldName.replace("#", "W");

                if (repeatValidateMap.containsKey(path)) {

                } else {
                    tableMappingRuleConfig.addJsonMappingRule(path, fieldName, ColumnTypesEnum.getTypeEnum(value), 100, null);
                    repeatValidateMap.put(path, path);
                }

            }
            jsonToSqlColumnMaps.add(tableMappingRuleConfig);
        }
        //将json当做 datapipeline 配置成使用本地json文件配置
        dataPipeline.setDataSourceTypeEnum(DataSourceTypeEnum.server_file).addUploadFileConfig()
                .setFileContent(json)

                .endConfig()
                .setResponseDateTypeEnum(ResponseDataTypeEnum.json)
                .setPipelineName(PipilineNameEnun.request_param.getName());
//                .addTableConfig();
//                .setTableName(PipilineNameEnun.china_region_map.getName());

        //放入流水线执行队列表头
        DataPipelineGroup dataPipelineGroup =
                new DataPipelineGroup().setPayloads(Lists.newArrayList(new PipelineControllerPayload()
                        .setDataPipeline(new Supplier<DataPipeline>() {
                            @Override
                            public DataPipeline get() {
                                return dataPipeline;
                            }
                        }).setPipelineExecStrategyEnum(PipelineExecStrategyEnum.one_by_one)));
        //此处还可以在队列头进行动态添加，由于还没有到真正的流水线执行阶段
        List<DataPipelineGroup> dataPipelineGroupsForReplace = new ArrayList<>();

        //添加到队列头
        dataPipelineGroupsForReplace.add(dataPipelineGroup);
        //添加其他流水线到队尾
        dataPipelineGroupsForReplace.addAll(this.dataPipelineGroups);
        this.dataPipelineGroups = dataPipelineGroupsForReplace;
        return this;
    }


    /***
     * 动态将数据生成到 table,这里和上面不一样的是这里使用的
     * @param currentPipelineName 当前正在执行请求的数据流水线名称，主要是用于将新生成的数据流水线放置到这个数据流水先后面
     * @param json
     * @return
     */
    public DataPipeLineController autoMappingToTableForPipelineExe(String currentPipelineName, String json) {
        DataPipeline dataPipeline = new DataPipeline();
        StringBuilder outputNoBeginEndTag = new StringBuilder();
        StringBuilder outputwithBeginEndTag = new StringBuilder();
        JsonToListMapUtil jsonToListMapUtil = new JsonToListMapUtil(json, outputNoBeginEndTag, outputwithBeginEndTag, dataPipeline);

        List<KeyValue> list = jsonToListMapUtil.getJsonListMap();

        /***
         * 过滤出来合适keyvalue数据
         */
        List<KeyValue> filterList = jsonAutoMappingMessageFilter(list);

        Map<String, List<KeyValue>> listMap = AutoGenerateJsonTable.getGroupPath(filterList);
        Map<String, Set<KeyValue>> setMap = AutoGenerateJsonTable.compressionPath(listMap);

        List<TableMappingRuleConfig> jsonToSqlColumnMaps = new ArrayList<>();
        for (String key : setMap.keySet()) {
            /***
             * 将datapipeline引入传入mapping rule的添加程序中，表的映射规则会自动添加到datapipeline中
             */
            TableMappingRuleConfig tableMappingRuleConfig = new TableMappingRuleConfig(dataPipeline);
            Set<KeyValue> keyValues = setMap.get(key);
            key = key.replace(".", "P");
            key = key.replace("_", "L");
            key = key.replace("[]", "A");
            key = key.replace("#", "W");
            tableMappingRuleConfig.setTableName( key + "_" +currentPipelineName);

            Map<String, String> repeatValidateMap = new HashMap<>();
            for (KeyValue keyValue : keyValues) {
                String path = keyValue.getKey();
                Object value = keyValue.getValue();
                String fieldName = path.replace(".", "P");
                fieldName = fieldName.replace("_", "L");
                fieldName = fieldName.replace("[]", "A");
                fieldName = fieldName.replace("#", "W");

                if (repeatValidateMap.containsKey(path)) {

                } else {
                    tableMappingRuleConfig.addJsonMappingRule(path, fieldName, ColumnTypesEnum.getTypeEnum(value), 100, null);
                    repeatValidateMap.put(path, path);
                }

            }
            jsonToSqlColumnMaps.add(tableMappingRuleConfig);
        }
        //将json当做 datapipeline 配置成使用本地json文件配置
        dataPipeline.setDataSourceTypeEnum(DataSourceTypeEnum.server_file).addUploadFileConfig()
                .setFileContent(json)

                .endConfig()
                .setResponseDateTypeEnum(ResponseDataTypeEnum.json)
                .setPipelineName(PipilineNameEnun.request_param.getName());
//                .addTableConfig();
//                .setTableName(PipilineNameEnun.china_region_map.getName());


        /***
         * 这一步是将数据自动生成的datapipeline对象，放置到执行队列里（datapipelinegroup）
         * 由于在执行之前这里是有一个datapipline的请求对象，所以只需要在这个pipeline执行完之后将生成的datapiline对象放置到请求pipeline所在的group中就行
         */
        for (DataPipelineGroup dataPipelineGroupForErgodic : dataPipelineGroups) {
            for (PipelineControllerPayload pipelineControllerPayload : dataPipelineGroupForErgodic.getPayloads()) {

                if (pipelineControllerPayload.getDataPipeline(this).getPipelineName().equals(currentPipelineName)) {
                    dataPipelineGroupForErgodic.getPayloads().addAll(Lists.newArrayList(new PipelineControllerPayload()
                            .setDataPipeline(new Supplier<DataPipeline>() {
                                @Override
                                public DataPipeline get() {
                                    return dataPipeline;
                                }
                            }).setPipelineExecStrategyEnum(PipelineExecStrategyEnum.one_by_one)));

                    return this;
                }
            }

        }

        return this;
    }

    /***
     * 首先对原始消息进行过滤
     * @param keyValueList
     * @return
     */
    public List<KeyValue> jsonAutoMappingMessageFilter(List<KeyValue> keyValueList) {
        List<KeyValue> filterResult = new ArrayList<>();
        for (KeyValue keyValue : keyValueList) {
            if (keyValue.getKey().endsWith("##.##")) {
                continue;
            }
            boolean isCommonValue = JsonOpereationEnum.isJsonOperationTag(keyValue.getValue());
            //存在一些自定义的key值 比如 _.data.arrray[]:9 这种是为了方便对数组进行标注，所以在判断自动入库的时候需要过滤掉
            boolean isCustomArrayEnd = keyValue.getKey().endsWith("[]");

            if (!isCommonValue && !isCustomArrayEnd) {
                filterResult.add(keyValue);
            }
        }
        return filterResult;
    }


    public Dversion getDversion(){
        return this.dversion;
    }
    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("dataPipelineGroups", dataPipelineGroups)
                .add("dataPipelineNameToRequestParams", dataPipelineNameToRequestParams)
                .add("userRequestMap", userRequestMap)
                .add("dataPipelineMap", dataPipelineMap)
                .add("responseDataFormat", responseDataFormat)
                .add("connection", connection)
                .add("sqlOperation", sqlOperation)
                .add("globalRequestContext", globalRequestContext)
                .add("errorMsg", errorMsg)
                .toString();
    }
}

